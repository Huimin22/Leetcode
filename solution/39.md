## 1. Problem

    
## 2. Idea

DFS
Go through all possible paths in a tree.

## 3. Key Points
DFS + Backtracking Template
```
def solve(candidates, target):
    res = []

    def dfs(start, path, total):
        if total == target:         # base case: valid combination
            res.append(path[:])
            return
        if total > target:          # pruning
            return
        for i in range(start, len(candidates)):  # loop over choices
            path.append(candidates[i])          # choose
            dfs(i, path, total + candidates[i]) # recurse
            path.pop()                          # backtrack

    dfs(0, [], 0)  # start recursion
    return res
```

Core Points / How to Adapt

DFS (recursion) → explore one path to the end

Loop over candidates → enumerate all choices at this level

start index → avoid duplicate combinations

path.append() / path.pop() → track choices and backtrack

Pruning (total > target) → stop impossible paths early

## 4. Code Implementation:


```
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        
        def dfs(start, path, total):
            if total == target:
                res.append(path[:])
            if total > target:
                return
            for i in range(start, len(candidates)):
                path.append(candidates[i])
                dfs(i, path, total+candidates[i])
                path.pop()

        dfs(0, [], 0)
        
        return res


```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
dfs(start, path, total)
start is the start index? why we don't use an element. Why will an index here work?
Why not pass the element directly?
Using the index in DFS lets us:

Reuse the same number multiple times (important for this problem).

Avoid generating duplicate combinations.

Keep recursion logic simple and ordered.

