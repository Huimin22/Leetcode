## 1. Problem

    
## 2. Idea

DFS
Go through all possible paths in a tree.

**Code logic:**

1. DFS and collect valid results: if path meets target, add to `res` and return.
2. Pruning: remove paths that do not satisfy the condition.
3. Exhaust all possible choices from `candidates`.
4. DFS recursion steps:

   * Choose: add current candidate to `path`.
   * Explore: DFS all paths from this branch.
   * Backtrack: remove last element from `path`.


## 3. Key Points
DFS + Backtracking Template
```
def solve(candidates, target):
    res = []

    def dfs(start, path, total):
        if total == target:         # base case: valid combination
            res.append(path[:])
            return
        if total > target:          # pruning
            return
        for i in range(start, len(candidates)):  # loop over choices
            path.append(candidates[i])          # choose
            dfs(i, path, total + candidates[i]) # recurse
            path.pop()                          # backtrack

    dfs(0, [], 0)  # start recursion
    return res
```

Core Points / How to Adapt

DFS (recursion) → explore one path to the end

Loop over candidates → enumerate all choices at this level

start index → avoid duplicate combinations

path.append() / path.pop() → track choices and backtrack

Pruning (total > target) → stop impossible paths early

## 4. Code Implementation:


```
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        
        def dfs(start, path, total):
            if total == target:
                res.append(path[:])
            if total > target:
                return
            for i in range(start, len(candidates)):
                path.append(candidates[i])
                dfs(i, path, total+candidates[i])
                path.pop()

        dfs(0, [], 0)
        
        return res


```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

dfs(start, path, total)
start is the start index? why we don't use an element. Why will an index here work?
Why not pass the element directly?
Using the index in DFS lets us:

Reuse the same number multiple times (important for this problem).

Avoid generating duplicate combinations.

Keep recursion logic simple and ordered.

**Second**

1. Confused index vs element: `for i in range()` iterates indices, need `candidates[i]` to get element.
2. Forgot path.append actually adds candidate to path.
3. Didn’t realize `start` controls repetition and pruning in DFS.
4. Overlooked backtracking: path.pop restores previous state.
5. Returned DFS result directly instead of collecting results in `res`. DFS result is null. 

**Third**
   dfs(i, path, total + candidates[i])

   I used start instead of i. i is to take control of where to choose. start is fixed if we call the dfs function outside.

