## 1. Problem
5. Longest Palindromic Substring
    
## 2. Summary

Palindrome = symmetric around a center.

Two centers: single char (odd) or gap (even).

Expand left/right from each center, track the longest.


## 3. Key Points

A palindrome is symmetric, so it can be found by expanding from a center.

**Two types of centers:**

Odd-length → single character

Even-length → gap between two characters


Expand left and right from each center while characters match.

Track longest palindrome with start and end indexes.  

Check all indices as potential centers to cover all palindromes.


## 4. Code Implementation:


```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        start, end = 0, 0
        res = ""
        if len(s) < 1:
            return ""
        
        # Helper function: expand around a given center
        def helper(left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return right-left-1
        
        for i in range(len(s)):
            res_max = end - start
            len1 = helper(i, i)
            len2 = helper(i, i+1)
            cur_max = max(len1, len2)
            if cur_max > res_max: 
                end = i + cur_max//2
                start = i - (cur_max-1)//2
        return s[start:end+1]

```

## 5. Complexity Analysis
    Time：O(n^2)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
**Mistakes:**

Didn’t fully grasp the helper function’s role – it finds the longest palindrome around a center, not just checks if a string is a palindrome.

Confusion about centers – didn’t initially understand:

Odd-length → single character center

Even-length → gap between two characters

Calling the helper twice per index – initially unclear why both odd and even checks are necessary.

Tracking palindrome length – needed clarity on why we calculate right - left - 1 and update start/end.

The idea is not easy to think about. There are two cases when we start from the given center for each char in the str. One case is start from the str[i] ther other is str[i] str[i+1]. This is the key idea about the helper function. By that, we can figure longest substring for each center, that is each char. Then use a for loop to compare each longest substring. 

**Question**
why str[i] str[i+1] instead of str[i-1] str[i], due to symmetry?
Anyway, the helper function is the key. It is not like a common case.

**Second:**

Used wrong boundary in center expansion (left > 0 instead of left >= 0), which truncated valid palindromes.

Misunderstood integer division: // is floor, affecting start / end index calculation.

Not know how to get the end, start well. Need to take some time fto figure it out.

**Third:**

Forgot left >= 0 in the expand loop → invalid expansion

Length formula off by 2 (right - left - 1 needed)

Compared with max_len but never updated it

