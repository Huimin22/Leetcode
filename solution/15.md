## 1. Problem

    
## 2. Idea
Two pointer


## 3. Key Points
Sort First: Sorting the array is mandatory to use the two-pointer approach and handle duplicates easily.

Fix One, Solve Two: Iterate through the array, fixing one number ($nums[i]$) and turning the problem into a Two Sum problem for the remaining target ($-nums[i]$).

Two-Pointer Strategy: Use a Left ($L$) and Right ($R$) pointer to find pairs. 

Shift $L$ right if the sum is too small, and $R$ left if the sum is too large.

Skip Positives: If $nums[i] > 0$, stop immediately; no three positive numbers can sum to zero in a sorted array.

Triple De-duplication:

Outer: 

Skip $nums[i]$ if it's the same as $nums[i-1]$.

Inner (L): After finding a valid triplet, move $L$ past all identical numbers.

Inner (R): After finding a valid triplet, move $R$ past all identical numbers.

Sort-Two sum question-fix one, two pointer

Corner case Skip Positives

De-duplication: inner/outer loop


## 4. Code Implementation:

```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        for i in range(len(nums)-2):        
            if nums[i] > 0:
                return res
            if i > 0 and nums[i] == nums[i-1]:
                continue
            lp = i + 1
            rp = len(nums) - 1
            while lp < rp:
                if nums[i] + nums[lp] + nums[rp] == 0:
                    res.append([nums[i], nums[lp], nums[rp]])
                    while lp < rp and nums[lp] == nums[lp+1]:
                        lp += 1
                    while lp < rp and nums[rp] == nums[rp-1]:
                        rp -= 1
                    lp += 1
                    rp -= 1
                elif nums[i] + nums[lp] + nums[rp] > 0:
                    rp -= 1
                else:
                    lp += 1
        return res 

```

## 5. Complexity Analysis
    Time：$O(n^2)$ time complexity due to the nested loop and two-pointer scan.
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
De-duplication is important: inner/outer loop

## 9. Mistakes
Incorrect i De-dupe: Avoid using nums[i] == nums[i+1], as this skips potential valid triplets; always compare with the previous element nums[i-1].

Missing lp < rp check: Always include this boundary check inside your while de-duplication loops to prevent "Index Out of Range" errors.

Forgetting the Final Move: After finding a sum of zero and skipping duplicates, failing to move lp and rp one last time will result in an infinite loop.

**Second Time**
Optimize:

if nums[i] > 0:
                break

Use a constance to record total:

total = nums[i] + nums[left] + nums[right]

Mistakes:
Find 0 → skip duplicates → move both pointers.
After skipping duplicates, you didn’t clearly move left and right pointers, which can cause missed triplets or infinite loops.

code
'''
 if total == 0:
                    res.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[right] == nums[right-1]:
                        right -= 1
                    while left < right and nums[left] == nums[left+1]:
                        left += 1 
                    right -= 1
                    left += 1  
'''

I didn’t write the code this way; I had put the while loops elsewhere. I didn’t realize that we should skip duplicates immediately after finding a valid triplet, and I didn’t move both pointers after finding the target result.



