## 1. Problem
21. Merge Two Sorted Lists
    
## 2. Summary

Use pointers (cur, list1, list2) to traverse lists.

Compare list1.val & list2.val; attach smaller node to cur.next.

Create a new linked list with dummy node to store the result list.

## 3. Key Points

Use pointers (cur, list1, list2) to traverse lists.

Dummy node simplifies merging.

Compare current nodes, attach the smaller to cur.next.

Move cur and the list pointer that provided the node.

After traversal, attach remaining nodes.


## 4. Code Implementation:

```
   # Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        cur = dummy
        while list1 and list2:
            if list1.val < list2.val:
                cur.next = list1
                list1 = list1.next
            else:
                cur.next = list2
                list2 = list2.next
            cur = cur.next
        if list1:
            cur.next = list1
        elif list2:
            cur.next = list2
        return dummy.next



```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note


### **1️⃣ Node vs Pointer Variable**

* **Node (ListNode)**:

  * Represents a single node (like a train car) with `val` and `.next`.
  * Fixed in memory; does **not move**.
* **Pointer variable (e.g., `list1`, `cur`)**:

  * Stores a reference/address of a node (like a ticket pointing to a car).
  * Can move along the list (`cur = cur.next`) to traverse nodes.
* **.next**:

  * Static property of a node (the hook).
  * Points to another node; does **not move** by itself.

---

### **2️⃣ Traversal**

* To traverse a list:

```python
cur = head
while cur:
    # process cur
    cur = cur.next  # move to next node
```

* `cur` moves; nodes stay put.
* `.next` only tells you where to go next.

---

### **3️⃣ Inserting / Linking Nodes**

* `cur.next = list1` → cur’s hook now points to **the node that list1 currently points to**, not to the variable `list1` itself.
* Multiple `.next` pointers can point to the same node (shared references).
* Changing `cur.next` does not move the node; it just reroutes the chain.

---

### **4️⃣ Key Mental Model (Train Analogy)**

| Concept             | Train Analogy                             |
| ------------------- | ----------------------------------------- |
| Node                | Carriage, fixed in place                  |
| .next               | Hook on carriage pointing to next         |
| Pointer (cur/list1) | Ticket/position, can move along carriages |

* Traversing = moving the ticket (pointer) along the hooks
* Inserting = hooking one carriage onto another via the hooks
* Nodes themselves never move; only the references (pointers) do.

---

### **5️⃣ Common Confusions Clarified**

1. `list1` looks like a node because you can do `list1.val`, but it’s actually a **reference variable**.
2. `cur.next` is static; assignment `cur.next = list1` reroutes the hook, node itself is unchanged.
3. Traversal is moving a pointer, not moving nodes.
4. Multiple hooks can point to the same node; node data is shared.



