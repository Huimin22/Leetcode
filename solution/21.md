## 1. Problem
21. Merge Two Sorted Lists
    
## 2. Summary

Use pointers (cur, list1, list2) to traverse lists.

Compare list1.val & list2.val; attach smaller node to cur.next.

Create a new linked list with dummy node to store the result list.

## 3. Key Points

Use pointers (cur, list1, list2) to traverse lists.

Dummy node simplifies merging.

Compare current nodes, attach the smaller to cur.next.

Move cur and the list pointer that provided the node.

After traversal, attach remaining nodes.


## 4. Code Implementation:

```
   # Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        cur = dummy
        while list1 and list2:
            if list1.val < list2.val:
                cur.next = list1
                list1 = list1.next
            else:
                cur.next = list2
                list2 = list2.next
            cur = cur.next
        if list1:
            cur.next = list1
        elif list2:
            cur.next = list2
        return dummy.next



```

## 5. Complexity Analysis
    Timeï¼šO(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

### **Linked list pointers vs nodes**

1. **Node itself = the train carriage in memory**

   * Each node has fixed data (`val`) and a hook (`.next`).
   * The node exists at a fixed location in memory and **does not move on its own**.
   * You can think of it as a â€œvirtual conceptâ€ â€” a memory block storing data and the address of the next node.

2. **Pointer variable (e.g., `list1`) = the ticket/reference**

   * Stores the address (reference) of a node.
   * Can freely change which node it points to.
   * Essentially, it is â€œmovableâ€ and used to traverse the list.

3. **`.next` = static hook**

   * Each node comes with it, pointing to the next node.
   * It does **not move by itself**, it just provides information.
   * When you write:

   ```python
   cur.next = list1
   ```

   1. The hook `.next` of the `cur` node is changed to point to the node that `list1` currently references.
   2. The node `list1` points to itself does **not move**, and its `.next` remains unchanged.

ðŸ”¥ Core idea: `.next` is a static hook; assigning it only changes which node it points to.





### **1ï¸âƒ£ Node vs Pointer Variable**

* **Node (ListNode)**:

  * Represents a single node (like a train car) with `val` and `.next`.
  * Fixed in memory; does **not move**.
* **Pointer variable (e.g., `list1`, `cur`)**:

  * Stores a reference/address of a node (like a ticket pointing to a car).
  * Can move along the list (`cur = cur.next`) to traverse nodes.
* **.next**:

  * Static property of a node (the hook).
  * Points to another node; does **not move** by itself.

---

### **2ï¸âƒ£ Traversal**

* To traverse a list:

```python
cur = head
while cur:
    # process cur
    cur = cur.next  # move to next node
```

* `cur` moves; nodes stay put.
* `.next` only tells you where to go next.

---

### **3ï¸âƒ£ Inserting / Linking Nodes**

* `cur.next = list1` â†’ curâ€™s hook now points to **the node that list1 currently points to**, not to the variable `list1` itself.
* Multiple `.next` pointers can point to the same node (shared references).
* Changing `cur.next` does not move the node; it just reroutes the chain.

---

### **4ï¸âƒ£ Key Mental Model (Train Analogy)**

| Concept             | Train Analogy                             |
| ------------------- | ----------------------------------------- |
| Node                | Carriage, fixed in place                  |
| .next               | Hook on carriage pointing to next         |
| Pointer (cur/list1) | Ticket/position, can move along carriages |

* Traversing = moving the ticket (pointer) along the hooks
* Inserting = hooking one carriage onto another via the hooks
* Nodes themselves never move; only the references (pointers) do.

---

### **5ï¸âƒ£ Common Confusions Clarified**

1. `list1` looks like a node because you can do `list1.val`, but itâ€™s actually a **reference variable**.
2. `cur.next` is static; assignment `cur.next = list1` reroutes the hook, node itself is unchanged.
3. Traversal is moving a pointer, not moving nodes.
4. Multiple hooks can point to the same node; node data is shared.


**Second**
Pass.

Have issue with the function in lc21 when solving the lc 23.

mergedTwo Function, have an issue: cur = dummy.next

Don't get the pointer cur, this means the start position, dummy.next is None. 

.next concept is not clearly understood.
