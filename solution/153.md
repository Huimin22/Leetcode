## 1. Problem
153. Find Minimum in Rotated Sorted Array
    
## 2. Summary

Binary search

* The key to binary search is comparing `mid` with `right`.
* **Large segment:** `nums[mid] > nums[right]` → minimum must be in the right half.
* **Small segment:** `nums[mid] <= nums[right]` → minimum must be in the left half (including `mid`).
* Each time we shrink the search range, we **never discard the minimum**, and eventually `left == right` points to the minimum.


## 3. Key Points


### Binary Search Logic

We pick `mid = (left + right) // 2` and compare `nums[mid]` with `nums[right]`.

#### Case 1: `nums[mid] > nums[right]`

* This means `mid` is in the **larger ascending part**.

  * If `mid` were in the smaller ascending part, we would have `nums[mid] <= nums[right]`.
* Therefore, the minimum **cannot** be in `[left, mid]`; it must be in `[mid + 1, right]`.
* ✅ Shrink the left boundary: `left = mid + 1`.

#### Case 2: `nums[mid] <= nums[right]`

* This means `mid` is in the **smaller ascending part**, or it could be the minimum itself.
* Therefore, the minimum is definitely in `[left, mid]`.
* ✅ Shrink the right boundary: `right = mid`.

## 4. Code Implementation:

```
   class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right  = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[right]:
                left = mid + 1           
            else:
                right = mid
        return nums[left]
```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

The distribution of mid has two cases: 

one is that the right side of mid is strictly ascending, and the minimum is in the left half; 

the other is that the left side of mid is strictly ascending, and the minimum is in the right half. 

By first checking nums[mid] > nums[right], we know the minimum is definitely in the right half of mid, excluding mid itself.

**Second**

Pass

**Third**

Pass

The distribution of mid has two cases: one is that the right side of mid is strictly ascending, and the minimum is in the left half; the other is that the left side of mid is strictly ascending, and the minimum is in the right half. By first checking nums[mid] > nums[right], we know the minimum is definitely in the right half of mid, excluding mid itself.


