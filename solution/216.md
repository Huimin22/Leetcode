## 1. Problem

    
## 2. Idea

DFS
lc 39

## 3. Key Points
Candidates set is fixed

LC 39: arbitrary list candidates.

LC 216: numbers 1–9 only → no duplicates in input.


Combination size limit

LC 216 requires exactly k numbers, so DFS tracks path length.

LC 39: any number of elements summing to target.


Index control (no reuse)

Each number used at most once, so dfs(i + 1, …).

Same as LC 40; different from LC 39 (dfs(i, …) allows reuse).


Sorting is implicit

Numbers 1–9 are naturally ordered → pruning works without explicit sort.

Can still use if total + nums[i] > target: break for efficiency.


Pruning & early exit

Stop recursion if total > target or len(path) > k.



## 4. Code Implementation:


```

class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []
        cand = [1, 2, 3, 4, 5, 6, 7, 8, 9]

        def dfs(start, path, total, level):
            if level > k:
                return
            if total > n:
                return 
            if total == n and level == k:
                res.append(path[:])       
            for i in range(start, len(cand)):
                path.append(cand[i])
                dfs(i+1, path, total+cand[i], level+1)
                path.pop()

        dfs(0, [], 0, 0)
        return res        

```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
The key is to keep track of the level and prune. Add a level para to get the res we want. 
Second is no reapeat. 


