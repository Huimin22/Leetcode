## 1. Problem

104. Maximum Depth of Binary Tree
    
## 2. Summary

Height = number of levels, not number of nodes.

BFS must process level by level.

size = len(queue) → current level size.

for loop → process one full level.

depth += 1 after finishing each level.

While controls levels.
For controls nodes in current level.

## 3. Key Points

Goal: count levels.

If root is null → return 0.

BFS version:
Queue init with root.

While queue:

 size = len(queue)   ← current level
 
 for size times:
 
  pop node
  
  push left/right if exist
  
 depth += 1

Return depth.

**Key idea:
While = levels loop
For = process one level
Depth += 1 after each level**

## 4. Code Implementation:

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    from collections import deque

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        q = deque([root])
        res = 0
        while q:
            size = len(q)
            for _ in range(size):
                ele = q.popleft()
                if ele.left:
                    q.append(ele.left)
                if ele.right:
                    q.append(ele.right)
            res += 1

        return res   
```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

Why BFS is used for shortest path (Follow-up Summary)

**Core Reason**

BFS explores nodes **level by level**.

In an unweighted graph:

* Level = number of edges from the start node
* First time reaching a node = shortest path to that node

So when the target is first found, that path is guaranteed to be the shortest.

---

### Mental Model

> BFS guarantees shortest path in unweighted graphs because it explores by distance (level order).

* **BFS = shortest path (unweighted graph)**
  → Expands in waves
  → Guarantees minimum steps

* **DFS = full path exploration**
  → Goes deep first
  → Does NOT guarantee shortest path


## 8. Note
