## 1. Problem

424. Longest Repeating Character Replacement
    
## 2. Idea

Use pointers to maintain sliding window

## 3. Key Points

Use a sliding window [left, right] to track a substring.

Maintain a frequency dictionary of characters in the window.

Track max_count = count of the most frequent character in the window.

Window is valid if (window_length - max_count) <= k (i.e., at most k replacements needed).

Expand the window with the right pointer; shrink from left when invalid.

Result = maximum window length encountered.


## 4. Code Implementation:


```
code v1
class Solution:
   
    def characterReplacement(self, s: str, k: int) -> int:
        max_cnt  = 0
        cnt_dic = {}
        lp, rp = 0, 0
        res = 0

        for rp in range(len(s)):
            cnt_dic[s[rp]] = cnt_dic.get(s[rp], 0) + 1 
            max_cnt = max(max_cnt, cnt_dic[s[rp]]) 
            while (rp-lp+1-max_cnt) > k:           
                cnt_dic[s[lp]] = cnt_dic.get(s[lp], 0) - 1
                lp += 1            
            res = max(rp-lp+1, res)

        return res
  

```


```
code v2
class Solution:
    from collections import defaultdict
    
    def characterReplacement(self, s: str, k: int) -> int:
        max_cnt  = 0
        cnt_dic = defaultdict(int)
        lp, rp = 0, 0
        res = 0

        for rp in range(len(s)):
            cnt_dic[s[rp]] += 1
            max_cnt = max(max_cnt, cnt_dic[s[rp]]) 
            while (rp-lp+1-max_cnt) > k:           
                cnt_dic[s[lp]] -= 1
                lp += 1            
            res = max(rp-lp+1, res)

        return res
   
```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
Not know very well.

Use defaultdict(int) or dict.get(char, 0) to handle frequencies safely.

max_count only needs to increase when adding a character; no need to recalc on every left shrink.

Return maximum valid window length, not max_count.

**Second Time:**

max_cnt = 0 — not familiar with using it as a state variable to track the max frequency in the window.

In the while loop, I define a constant outside, but I always move the pointer first before updating cnt_dic.

cnt_dic = defaultdict(int) — not familiar with how to use defaultdict.

**Third Time:**

Pass
Sliding window

**Fourth Time:**

max_cnt = 0 — not familiar with using it as a state variable to track the max frequency in the window.

Need to update the dict first with left after left+1.

Spend 30 mins figuring out why update the max_cnt when udpat the sliding window.

Core logic

**Meaning of `max_cnt`**

* Records “the maximum frequency of any character seen so far,” not the exact max frequency of the current window.
* Used to check if the current window can be valid:

```
(right - left + 1) - max_cnt <= k
```

* If true → window is valid → update `res`.

**Why `max_cnt` doesn’t need updating**

* When the right pointer moves, `max_cnt` is updated with the new character → only increases.
* Each expanding window tries to update `res`.
* The window that could become the **true maximum length** will appear during right-pointer expansion.
* Left-pointer moves only keep the window valid.
* Left-pointer moves **cannot create a new larger valid window**.
* Therefore, `res` is updated to the maximum **only during right-pointer expansion**.

**Intuitive view**

* Finding the longest repeating-character window.
* Right moves → expand window → `max_cnt` may increase → update `res`.
* Left moves → just keep window valid → cannot produce a larger length.

So the **true maximum** is captured during right-pointer expansion.
Stale `max_cnt` during left moves is fine — it may temporarily make the window larger, but it **doesn’t miss the answer**.

✅ Summary in one sentence:

The maximum length is determined when the right pointer expands and `max_cnt` increases; not updating `max_cnt` during left-pointer shrinkage **does not affect the final answer**, because other windows can only approach but not exceed this maximum.

## 9. Key Mistakes

rp += 1 inside a for → IndexError.

Returning max_cnt instead of max window length → wrong answer.

Shrinking left pointer in wrong order (lp += 1 before decrement) → wrong frequency.

Using plain dict without default → KeyError.

Not handling missing keys with .get() if using plain dict → KeyError.

1️⃣ Manually incrementing rp inside a for loop
for rp in range(len(s)):
    rp += 1  # ❌


Mistake: for already moves rp; manually incrementing causes IndexError when accessing s[rp].

Fix: Remove rp += 1.

2️⃣ Returning max_cnt instead of the window length
return max_cnt  # ❌


Mistake: max_cnt is the count of the most frequent character in a window, not the length of the longest valid substring.

Fix: Return res, which tracks rp - lp + 1 max.

3️⃣ Left pointer shrink order
lp += 1
cnt_dic[s[lp]] -= 1  # ❌ wrong order


Mistake: You move lp first, then decrement → you skip reducing the frequency of the character that’s actually leaving the window.

Fix:

cnt_dic[s[lp]] -= 1
lp += 1

4️⃣ Using ordinary dict without default value
cnt_dic[s[rp]] += 1  # ❌ if key doesn’t exist → KeyError


Mistake: Ordinary dict {} doesn’t auto-initialize keys.

Fixes:

Use cnt_dic[s[rp]] = cnt_dic.get(s[rp], 0) + 1

Or use defaultdict(int) and then cnt_dic[s[rp]] += 1

5️⃣ Not handling left pointer with .get() (if using ordinary dict)
cnt_dic[s[lp]] -= 1  # ❌ KeyError if key missing


Fix:

cnt_dic[s[lp]] = cnt_dic.get(s[lp], 0) - 1

Summary of Your Key Mistakes

Manual pointer increment inside for loop → IndexError

Returning max_cnt instead of longest window → wrong answer

Shrinking left pointer in wrong order → wrong frequencies

Using ordinary dict without default → KeyError

Forgetting .get() for safety → KeyError

