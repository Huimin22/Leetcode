## 1. Problem

    
## 2. Idea

Use pointers to maintain sliding window

## 3. Key Points

Use a sliding window [left, right] to track a substring.

Maintain a frequency dictionary of characters in the window.

Track max_count = count of the most frequent character in the window.

Window is valid if (window_length - max_count) <= k (i.e., at most k replacements needed).

Expand the window with the right pointer; shrink from left when invalid.

Result = maximum window length encountered.


## 4. Code Implementation:


```
code v1
class Solution:
   
    def characterReplacement(self, s: str, k: int) -> int:
        max_cnt  = 0
        cnt_dic = {}
        lp, rp = 0, 0
        res = 0

        for rp in range(len(s)):
            cnt_dic[s[rp]] = cnt_dic.get(s[rp], 0) + 1 
            max_cnt = max(max_cnt, cnt_dic[s[rp]]) 
            while (rp-lp+1-max_cnt) > k:           
                cnt_dic[s[lp]] = cnt_dic.get(s[lp], 0) - 1
                lp += 1            
            res = max(rp-lp+1, res)

        return res
  

```


```
code v2
class Solution:
    from collections import defaultdict
    
    def characterReplacement(self, s: str, k: int) -> int:
        max_cnt  = 0
        cnt_dic = defaultdict(int)
        lp, rp = 0, 0
        res = 0

        for rp in range(len(s)):
            cnt_dic[s[rp]] += 1
            max_cnt = max(max_cnt, cnt_dic[s[rp]]) 
            while (rp-lp+1-max_cnt) > k:           
                cnt_dic[s[lp]] -= 1
                lp += 1            
            res = max(rp-lp+1, res)

        return res
   
```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
Not know very well.

Use defaultdict(int) or dict.get(char, 0) to handle frequencies safely.

max_count only needs to increase when adding a character; no need to recalc on every left shrink.

Return maximum valid window length, not max_count.

**Second Time:**

max_cnt = 0 — not familiar with using it as a state variable to track the max frequency in the window.

In the while loop, I define a constant outside, but I always move the pointer first before updating cnt_dic.

cnt_dic = defaultdict(int) — not familiar with how to use defaultdict.

**Third Time:**
Pass
Sliding window

## 9. Key Mistakes

rp += 1 inside a for → IndexError.

Returning max_cnt instead of max window length → wrong answer.

Shrinking left pointer in wrong order (lp += 1 before decrement) → wrong frequency.

Using plain dict without default → KeyError.

Not handling missing keys with .get() if using plain dict → KeyError.

1️⃣ Manually incrementing rp inside a for loop
for rp in range(len(s)):
    rp += 1  # ❌


Mistake: for already moves rp; manually incrementing causes IndexError when accessing s[rp].

Fix: Remove rp += 1.

2️⃣ Returning max_cnt instead of the window length
return max_cnt  # ❌


Mistake: max_cnt is the count of the most frequent character in a window, not the length of the longest valid substring.

Fix: Return res, which tracks rp - lp + 1 max.

3️⃣ Left pointer shrink order
lp += 1
cnt_dic[s[lp]] -= 1  # ❌ wrong order


Mistake: You move lp first, then decrement → you skip reducing the frequency of the character that’s actually leaving the window.

Fix:

cnt_dic[s[lp]] -= 1
lp += 1

4️⃣ Using ordinary dict without default value
cnt_dic[s[rp]] += 1  # ❌ if key doesn’t exist → KeyError


Mistake: Ordinary dict {} doesn’t auto-initialize keys.

Fixes:

Use cnt_dic[s[rp]] = cnt_dic.get(s[rp], 0) + 1

Or use defaultdict(int) and then cnt_dic[s[rp]] += 1

5️⃣ Not handling left pointer with .get() (if using ordinary dict)
cnt_dic[s[lp]] -= 1  # ❌ KeyError if key missing


Fix:

cnt_dic[s[lp]] = cnt_dic.get(s[lp], 0) - 1

Summary of Your Key Mistakes

Manual pointer increment inside for loop → IndexError

Returning max_cnt instead of longest window → wrong answer

Shrinking left pointer in wrong order → wrong frequencies

Using ordinary dict without default → KeyError

Forgetting .get() for safety → KeyError

