
## 1. Problem

    
## 2. Summary
Greedy

Including nums[i] is necessary — we are deciding: extend the previous product or start new?  

Track the cur_min and cur_max for a subarray ending at i.

Corner case is when nums[i] could be negetive, need to swap cur_min and cur_max.
Cuz cur_min could be cur_max, cur_max could be cur_min. If not negetive, just keep it.


## 3. Key Points

At each index i, we want to track the range of possibilities for a subarray ending at i:

cur_max → the maximum product of any subarray ending at i

cur_min → the minimum product of any subarray ending at i

Why track both?

Because multiplying a negative number flips max ↔ min.

A very small negative product could become the largest if the next number is negative.

Then to compare cur_max cincluding nums[i] this time with the max_pro we have so far.

## 4. Code Implementation:


```
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        cur_max = cur_min = max_pro = nums[0]
    
        for i in range(1, len(nums)):
            if nums[i] < 0:
                cur_max, cur_min = cur_min, cur_max
            cur_max = max(cur_max*nums[i], nums[i])
            cur_min = min(cur_min*nums[i], nums[i])
            max_pro = max(cur_max, max_pro)
        return max_pro   
```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

**Second**

Mistake:

cur_min = max(cur_min*nums[i], nums[i]) 

Should use min, to find the min one.






