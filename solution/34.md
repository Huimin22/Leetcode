# 解法思路：

## Binary Search
（1）先找最左边target’s index，再找最右边target‘s index，index1 ≤ index2，找到，否则没有

（2）最左边target’s index：中间值m，nums[m] ≥ t,t肯定在m左边，r=m-1; nums[m] < t, t肯定在m右边，l=m+1，这样确保可以找到最左边的t

（3）最右边target‘s index：中间值m，nums[m]  <  t, t肯定在m左边，r=m-1; nums[m] ≥ t, t肯定在m右边，l = m+1，这样确保可以找到最左边的t（要考虑nums[m]  = t，找最右的时候，就算等于，也要在右边找；找最左，等于情况要在左边找）

（4）最后要比较if index1 ≤ index2，否则没有

## 注意要点：

（1）分清到底是index还是值，变量设置的是index，比较大小的时候要用index的值来比较，查找index的时候经常犯这个错误

（2） 二分法条件 l ≤ r,记得要加=，l =m + 1,否则，像l < r；l = m,分到1 8的时候，8是target, l = m，l指针不能再往前，无法找到8
复杂度：

## 代码：
<img src='screenshot.png'>
