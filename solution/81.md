## 1. Problem

81. Search in Rotated Sorted Array II
    
## 2. Summary

“Check mid → shrink useless duplicates → detect sorted side → move boundaries”

## 3. Key Points

Core idea: Binary search with duplicates can break order info.

Quick check:

If nums[mid] == target → return True

If nums[left] == nums[mid] == nums[right] → shrink boundaries: left+=1, right-=1

Otherwise:

If left side sorted: nums[left] <= nums[mid] → check target in left → move left/right

Else right side sorted → check target in right → move left/right

Why shrink on duplicates: mid ≠ target → left/right also ≠ target → safe to discard, restores ability to detect sorted side.

Worst case: O(n) if all duplicates


The reason we can shrink the search range is that the values at the three positions are the same, and we have already confirmed that `mid` is not equal to the target. Since all three positions contain the same value, the boundary elements cannot be the target either. Therefore, it is safe to shrink the range.

If we do not handle this case and shrink the range, we will not be able to perform the later monotonic (sorted) interval check.

For example:

```
nums = [1,1,1,1,1]
target = 2
```

In this case, we cannot determine which side is sorted, so shrinking the range is necessary.


## 4. Code Implementation:

```
  class Solution:
    def search(self, nums: List[int], target: int) -> bool:

        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2

            if nums[mid] == target:
                return True

            if nums[left] == nums[mid] == nums[right]:
                right -= 1
                left += 1
                continue

            elif nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1

            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1

        return False 

```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

**Mistakes**

Missed the “all equal” case – nums[left] == nums[mid] == nums[right] → needed to handle separately, otherwise nums[left] <= nums[mid] check can be misleading.

Control flow issue – forgot elif or continue, so after shrinking boundaries, the next check could run on outdated mid/left/right, causing logical errors or IndexError.

I forgot to identify the case when nums[left] = nums[mid], they could be the same number.
