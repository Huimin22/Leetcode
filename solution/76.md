## 1. Problem
76. Minimum Window Substring （hard）
    
## 2. Summary

**“Expand right to satisfy → shrink left to minimize → track formed”

## 3. Key Points

1. **Sliding Window + Hash Maps**

   * `dict_t` → counts of chars in `t`
   * `window_counts` → counts of chars in current window

2. **Formed Counter**

   * `formed` = number of unique `t` chars currently satisfied in window
   * Window is valid if `formed == required`

3. **Expand Right Pointer**

   * Include new char in `window_counts`
   * If char satisfies requirement → `formed += 1`

4. **Shrink Left Pointer** (while window valid)

   * Try to minimize window length
   * Remove left char from `window_counts`
   * If removal breaks requirement → `formed -= 1`

5. **Update Answer**

   * Keep track of smallest valid window (`min_len, start, end`)

6. **Return Result**

   * Slice `s[start:end+1]` if found, else ""

## 4. Code Implementation:


```
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if not s or not t:
            return ""
        
        dict_t = Counter(t)
        required = len(dict_t)

        formed = 0
        left, right = 0, 0
        window_counts = defaultdict(int)

        ans = (float("inf"), None, None)

        while right < len(s):
            # update sliding window dict
            c = s[right]
            window_counts[c] += 1

            if c in dict_t and window_counts[c] == dict_t[c]:
                formed += 1
            
            while left <= right and formed == required:
                   # update sliding window
                if right - left + 1 < ans[0]:
                    ans = (right - left + 1, left, right)
                
                window_counts[s[left]] -= 1
                c_left = s[left]
                if c_left in dict_t and window_counts[c_left] < dict_t[c_left]:
                    formed -= 1
                
                left += 1
            
            right += 1

        if ans[0] == float("inf"):
            return ""

        else:
            return s[ans[1]: ans[2]+1]
```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
