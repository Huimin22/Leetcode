## 1. Problem

238. Product of Array Except Self
    
## 2. Summary

Prefix products and suffix product

* First pass = prefix products
* Second pass = rolling suffix product
* No division
* O(n) time, O(1) extra space


## 3. Key Points

```
Goal:
ans[i] = product of all numbers except nums[i]
       = left product * right product
```

Step 1 — Build left products in ans:

```
ans[0] = 1
for i in 1 → n-1:
    ans[i] = ans[i-1] * nums[i-1]
```

Step 2 — Multiply right products using one variable:

```
right = 1
for i in n-1 → 0:
    ans[i] *= right
    right *= nums[i]
```


## 4. Code Implementation:

```
   class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        pre = [1] * n
        suf = [1] * n
        res = [1] * n

        for i in range(1, n):
            pre[i] = pre[i-1] * nums[i-1]
        
        for j in range(n-2, -1, -1):
            suf[j] = suf[j+1] * nums[j+1] 

        for i in range(0, n):
            res[i] = pre[i] * suf[i]
        
        return res
```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

**Mistake**

1. **Shared list reference**

   ```
   pre = suf = res = [1] * n
   ```

   → All three variables pointed to the same list (mutable object issue).

2. **Not recognizing mutable vs immutable difference**
   → Confusion about why `m = n = 2` works but list chaining doesn’t.

3. **Over-initializing**
   → Created three arrays when problem can be done with one + one variable.

4. **Memory model awareness gap**
   → Didn’t immediately catch that modifying one list affects all references.


