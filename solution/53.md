## 1. Problem

    
## 2. Summary

Greedy idea

current_sum is contiguous subarray.

Rwo choices for current_sum:

current_sum + nums[i]

or restart → nums[i]

A max_sum to keep track the max_sum so far.

## 3. Key Points

We want a contiguous subarray with max sum.

At each step, you have two choices for current_sum:

Extend the previous subarray → current_sum + nums[i]

Start a new subarray from current element → nums[i]


Greedy idea: always pick the option that gives bigger sum.


## 4. Code Implementation:

```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_sum = current_sum = nums[0]
        for i in range(1, len(nums)):
            current_sum = max(nums[i], current_sum + nums[i])
            max_sum = max(current_sum, max_sum)
        return max_sum
   


```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

**Second：**

**“At every index, choose: restart here OR extend before — pick the bigger.”**

This is NOT a sliding window problem

You never move a left pointer

At each index, decide:
extend the previous subarray or start a new one

Reset logic is NOT based on zero.

Reset logic is based on which choice is larger, so cur_sum is important. 

It is the previous sum, if it is negetive, it is better start from curent index.

Mistake：

**I looked for pointer movement rules instead of making a local greedy decision at each index.**

Forced sliding window (left/right) onto a problem that doesn’t have window rules

Used 0 as the reset condition instead of comparing extend vs restart

