## 1. Problem

    
## 2. Idea



## 3. Key Points
Reuse: LC 39 allows repeating numbers (dfs(i,…)); LC 40 uses each number once (dfs(i+1,…)).

Duplicates: LC 39 needs no dedup; LC 40 skips same-value elements on the same recursion level (if i > start and nums[i]==nums[i-1]: continue).

Sorting: LC 39 sorts mainly for pruning; LC 40 sorts for pruning and tree-level dedup.

Summary:

LC 40 = LC 39 + “use once” + “skip same-level duplicates.”



## 4. Code Implementation:


```
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        uni_can = sorted(candidates)

        def dfs(start, path, total):
            if total == target:
                res.append(path[:])
            if total > target:
                return
            for i in range(start, len(uni_can)):
                if i > start and uni_can[i] == uni_can[i-1]:
                    continue
                path.append(uni_can[i])
                dfs(i+1, path, total+uni_can[i])
                path.pop()
        dfs(0, [], 0)
       
```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups
lc 39
lc 216

## 8. Note
1. Misunderstanding tree-level deduplication

You wrote:

if i >= start and uni_can[i] == uni_can[i-1]:
    continue


Mistake: i >= start skips even the first valid element at this recursion level, causing missing results.

Correct: i > start — only skip duplicates after the first element on the same tree level.

2. Confusing index control

LC 39 uses dfs(i, …) because numbers can repeat.

LC 40 requires dfs(i+1, …) because each number can be used at most once.

Mixing these rules can lead to either missing solutions or generating duplicates.

3. Result-level deduplication

You tried removing duplicates in res after DFS.

Weakness: if DFS is done correctly (sorted + tree-level dedup), res never needs dedup. Doing it afterward indicates DFS logic is incomplete.

4. Not fully leveraging sorting

Sorting is not just for pruning — in LC 40 it’s crucial for tree-level deduplication.

Without sorting, if candidates[i] == candidates[i-1] won’t correctly detect duplicates, leading to either extra or missing results.

Core takeaway

Your mistakes all revolve around misapplying tree-level deduplication and index control in DFS. Once you sort, use i > start for skip, and move index i+1 for recursion, the solution works correctly and no post-processing dedup is needed.

