## 1. Problem

33. Search in Rotated Sorted Array
    
## 2. Summary

Binary search

“Split → recurse → merge two → done”

The right half is strictly increasing acrroding to the problem.

## 3. Key Points

In a rotated array, one half is always sorted → use the sorted half to determine if the target lies within it.

Use mid each time to narrow down the search interval.

Be careful with comparison operators; include the equals sign to avoid missing boundary values.

How to cut the half, the right half is strictly increasing acrroding to the problem.

We can use middle number to reduce.

## 4. Code Implementation:

```
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1        
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1 
                else:
                    right = mid - 1
        return -1 


```

## 5. Complexity Analysis
    Time：O(logn)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

ums[left] <= target < nums[mid]

The leftmost number can be equal to the target (<=) because the target could be exactly nums[left].

The right side does not include equality (<) because we already checked nums[mid] separately — so it cannot be equal to the target again.

When checking the increasing segment with nums[left] <= nums[mid], the rightmost number and mid could be the same, especially if the array has length 1 or 2.

Therefore, we include equality on the left to avoid missing cases; otherwise, some targets might be skipped.

**Second**

1️⃣ The line 

if nums[left] <= nums[mid]:
    # left side is sorted / strictly increasing


The <= includes the case when nums[left] == nums[mid].

The idea is to check which side is “sorted”, so we know where the target could lie.

2️⃣ Why not just <?

If you write:

if nums[left] < nums[mid]:


Then when nums[left] == nums[mid], this branch fails, and the code goes to the else branch.

But else is supposed to mean “the right side is sorted,” and that’s not necessarily true when nums[left] == nums[mid].

Example:
nums = [3, 1]
target = 3
left = 0, right = 1
mid = 0


nums[left] = nums[mid] = 3

If we use <, it goes to else, assuming right side is sorted

But actually, the left side is just a single element (3), which contains the target

We could miss the target if we don’t include equality

3️⃣ Why else doesn’t cover it

else is “everything else”, which the code interprets as “right side is sorted”

If nums[left] == nums[mid] and the array length is 1 or 2, the right side might not contain the target, but the left side does

So equality must be included in the first branch to handle edge cases

✅ Mental rule for rotated array binary search

nums[left] <= nums[mid] → left side is sorted (including single-element case)

else → right side is sorted

Always check equality on the side you assume is sorted, otherwise you risk skipping the target.
