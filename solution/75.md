## 1.Problem
75. Sort Colors
    
## 2.Idea

Use three points

## 3.Key Points

l = boundary of 0s (all left of l are 0)

r = boundary of 2s (all right of r are 2)

[l, k) = boundary of 1s (all are 1)

[k, r] = unknown / unexplored region

mistakes:

- **Loop boundary mistake** – using `while k < r` instead of `while k <= r`
    - Causes the last element in the unknown region to be skipped
- **Scanning pointer movement mistake** – forgetting `k += 1` after handling `nums[k] == 0`
    - Causes either skipped elements or potential dead loops

since [l, k) = boundary of 1s (all are 1), don’t need to worry about the swapped `nums[k]`, `k += 1` 

## 4.Code Implementation:

```
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        l, k = 0, 0 
        r = len(nums) - 1
        while k <= r:
            if nums[k] == 0:
                nums[k], nums[l] = nums[l], nums[k]
                l += 1  
                k += 1                         
            elif nums[k] == 2:
                nums[k], nums[r] = nums[r], nums[k]
                r -= 1
            elif nums[k] == 1:
                k += 1
        return nums

```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
I know how boundary works. Still need to be careful with the close/open boundary.
using `while k < r` instead of `while k <= r`, k is the index to explore unknown elements.

forgetting `k += 1` after handling `nums[k] == 0`. I use a while loop here, it won't add elements automatically, if we wantto move k, we have to add k plus 1. It is very important to know when to move k, when not. There are different cases to move k, due to the boundary. 
That's why the close/open status needs attention.
l = boundary of 0s (all left of l are 0)

r = boundary of 2s (all right of r are 2)

[l, k) = boundary of 1s (all are 1)

[k, r] = unknown / unexplored region
