## 1. Problem

    
## 2. Summary
Two pointers.

While-loop:

Right breaks it → left fixes it.

Index-jump:

Seen before cnt > 1 → jump left until right cnt is 1.

Longer version:

While-loop sliding window

Add right; if the window becomes invalid, move left forward and decrement counts until the condition is restored.

Index-jump

Track each character’s last index; when a duplicate appears inside the window, jump left to last_index + 1.

## 3. Key Points

Sliding window = current substring s[left : right+1]

right adds a character, may break the rule

while loop exists to fix the window, not to move pointers blindly

Move left → decrement counts → old chars disappear automatically

Window length is always right - left + 1


## 4. Code Implementation:


```
   class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = 0
        res_len = 0
        cnt_dic = defaultdict(int)
        for right in range(len(s)):
            cnt_dic[s[right]] += 1
            while cnt_dic[s[right]] > 1:
                cnt_dic[s[left]] -= 1
                left += 1
            res_len = max(res_len, right-left+1) 
        
        return res_len


```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note
**Mistakes**:

1. **Resetting the dict every iteration**

   ```python
   cnt_dic = defaultdict(int)
   ```

   * Mistake: This erases all previous character counts.
   * Consequence: The window cannot track duplicates correctly.

2. **Manually tracking `cur_len`**

   ```python
   cur_len += 1
   ```

   * Mistake: Sliding window length should be `right - left + 1`.
   * Consequence: Your `cur_len` can get out of sync and miss the max.

3. **Jumping `left` to `right + 1` blindly**

   ```python
   left = right + 1
   ```

   * Mistake: Ignores where the duplicate actually occurred.
   * Consequence: Skips valid parts of the substring, produces wrong results.

4. **Not updating `res_len` at the end**

   * Mistake: If the longest substring is at the very end, it is never counted.

5. **Misunderstanding sliding window invariant**

   * Mistake: Thought the dict represents *all past chars*, not just the current window.
   * Consequence: Confused why the while loop works and why we don’t reset the dict.

**One-line reflection:**

> I tried to “reset and jump” instead of maintaining a proper sliding window and updating the window dynamically.

**Second**

Fixed the bugs finally by myself and pass

Bugs: incorrect while-loop boundary; 

confusion about dict updates vs. pointer movement (add or subtract).

  ```python
  while left < right and cnt_dict[char] > 1:
                cnt_dict[s[left]] -= 1
                left += 1
   ```

**Third**
Pass

**Fourth**
Pass

**Fifth**
Pass
