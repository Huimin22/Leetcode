## 1. Problem

    
## 2. Summary
Two pointers.

While-loop:

Right breaks it → left fixes it.

Index-jump:

Seen before cnt > 1 → jump left until right cnt is 1.

Longer version:

While-loop sliding window

Add right; if the window becomes invalid, move left forward and decrement counts until the condition is restored.

Index-jump

Track each character’s last index; when a duplicate appears inside the window, jump left to last_index + 1.

## 3. Key Points

Sliding window = current substring s[left : right+1]

right adds a character, may break the rule

while loop exists to fix the window, not to move pointers blindly

Move left → decrement counts → old chars disappear automatically

Window length is always right - left + 1


## 4. Code Implementation:


```
   class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = 0
        res_len = 0
        cnt_dic = defaultdict(int)
        for right in range(len(s)):
            cnt_dic[s[right]] += 1
            while cnt_dic[s[right]] > 1:
                cnt_dic[s[left]] -= 1
                left += 1
            res_len = max(res_len, right-left+1) 
        
        return res_len


```

## 5. Complexity Analysis
    Time：O(n)
        
    Space: O(1)
        
## 6. Edge Cases

## 7. Follow-ups

## 8. Note

